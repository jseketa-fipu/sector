<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bot-Run Sector Map</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050816;
    }
    #mapCanvas {
      position: fixed;
      inset: 0;
      display: block;
      width: 100vw;
      height: 100vh;
      background: radial-gradient(circle at 20% 0%, #151b37 0, #050816 45%);
    }
  </style>
</head>
<body>
  <canvas id="mapCanvas"></canvas>

  <script>
    const canvas = document.getElementById("mapCanvas");
    let factionColors = {};
    let lastProj = {};
    let lastFrame = null;
    let tickDelayMs = 0;
    let lastRenderTs = 0;
    let renderScheduled = false;

    function resizeCanvas() {
      // Match the rendered size of the element to avoid any inset mismatch
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      if (lastFrame) render(lastFrame);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function render(data) {
      lastFrame = data;
      factionColors = {};
      (data.factions || []).forEach(f => { factionColors[f.id] = f.color || "#ffffff"; });

      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      const padding = 0;
      const innerW = w - 2 * padding;
      const innerH = h - 2 * padding;

      lastProj = {};
      let minPX = Infinity, maxPX = -Infinity, minPY = Infinity, maxPY = -Infinity;
      (data.systems || []).forEach(sys => {
        const p = { x: padding + sys.x * innerW, y: padding + sys.y * innerH };
        lastProj[sys.id] = p;
        minPX = Math.min(minPX, p.x);
        maxPX = Math.max(maxPX, p.x);
        minPY = Math.min(minPY, p.y);
        maxPY = Math.max(maxPY, p.y);
      });

      // Background stars
      ctx.save();
      ctx.globalAlpha = 0.15;
      for (let i = 0; i < 80; i++) {
        const x = Math.random() * w;
        const y = Math.random() * h;
        ctx.beginPath();
        ctx.arc(x, y, 0.5 + Math.random(), 0, Math.PI * 2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
      }
      ctx.restore();

      const systems = data.systems || [];
      const byId = {};
      systems.forEach(s => byId[s.id] = s);

      // Warp lanes
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(120, 140, 220, 0.35)";
      (data.lanes || []).forEach(([a,b]) => {
        const sa = byId[a], sb = byId[b];
        if (!sa || !sb) return;
        const pa = lastProj[sa.id], pb = lastProj[sb.id];
        if (!pa || !pb) return;
        ctx.beginPath();
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
        ctx.stroke();
      });
      ctx.restore();

      // Territories (Voronoi fill)
      const territoryCanvas = document.createElement("canvas");
      territoryCanvas.width = w;
      territoryCanvas.height = h;
      const tctx = territoryCanvas.getContext("2d");

      // Cover full canvas to avoid edge inset/clipping
      const startX = 0;
      const endX = w;
      const startY = 0;
      const endY = h;
      const maxVoronoiDist = 120;
      const step = 2;
      const owners = systems.map(s => s.owner);

      for (let y=startY; y<endY; y+=step) {
        for (let x=startX; x<endX; x+=step) {
          let bestIdx = -1, bestD2 = Infinity;
          for (let i=0; i<systems.length; i++) {
            const p = lastProj[systems[i].id];
            if (!p) continue;
            const dx = p.x - x;
            const dy = p.y - y;
            const d2 = dx*dx + dy*dy;
            if (d2 < bestD2) { bestD2 = d2; bestIdx = i; }
          }
          if (bestIdx === -1) continue;
          if (bestD2 > maxVoronoiDist * maxVoronoiDist) continue;
          const owner = owners[bestIdx];
          if (!owner) continue;
          const col = factionColors[owner] || "#888";
          tctx.fillStyle = col + "33";
          tctx.fillRect(x, y, step+1, step+1);
        }
      }

      // Soft glows around systems
      for (const sys of systems) {
        if (!sys.owner) continue;
        const p = lastProj[sys.id];
        const col = factionColors[sys.owner] || "#888";
        const r = 60;
        const grad = tctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
        grad.addColorStop(0, col + "22");
        grad.addColorStop(1, col + "00");
        tctx.fillStyle = grad;
        tctx.beginPath();
        tctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        tctx.fill();
      }

      ctx.save();
      // no clip; draw across the full canvas
      ctx.filter = "blur(8px)";
      ctx.drawImage(territoryCanvas, 0, 0);
      ctx.restore();

      // Systems + fleets
      const fleets = data.fleets || [];
      const fleetsBySystem = {};
      const enrouteFleets = [];
      fleets.forEach(fl => {
        if (fl.enroute_to !== null && fl.enroute_to !== undefined && fl.eta > 0) enrouteFleets.push(fl);
        else {
          if (fl.system_id === null || fl.system_id === undefined) return;
          (fleetsBySystem[fl.system_id] ||= []).push(fl);
        }
      });

      const highlights = new Set(data.highlight_ids || []);
      const tick = data.tick || 0;
      const phase = (tick % 40) / 40.0;
      const pulse = 0.5 + 0.5 * Math.sin(phase * Math.PI * 2);

      systems.forEach(sys => {
        const p = lastProj[sys.id];
        const value = typeof sys.value === "number" ? sys.value : 1;
        const r = 3 + value * 0.7;
        let color = "#44475a";
        if (sys.owner && factionColors[sys.owner]) color = factionColors[sys.owner];
        const isHighlight = highlights.has(sys.id);
        const isBesieged = !!sys.is_besieged;
        const heat = typeof sys.heat === "number" ? sys.heat : 0;
        const heatNorm = Math.max(0, Math.min(1, heat / 3.0));

        if (heatNorm > 0) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 8 + 6 * heatNorm, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 120, 80, ${0.15 + 0.25 * heatNorm})`;
          ctx.fill();
          ctx.restore();
        }

        if (isBesieged) {
          const tNow = (typeof performance !== "undefined" ? performance.now() : Date.now());
          const siegePulse = 0.6 + 0.4 * Math.sin(tNow / 400);
          ctx.save();
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 8 + siegePulse * 3, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(255, 123, 123, 0.95)";
          ctx.lineWidth = 2.5;
          ctx.shadowBlur = 6;
          ctx.shadowColor = "rgba(255, 123, 123, 0.9)";
          ctx.stroke();
          ctx.restore();
        }

        if (isHighlight) {
          ctx.save();
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 6 + pulse * 2, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + 0.4 * pulse})`;
          ctx.lineWidth = 1.5 + pulse;
          ctx.stroke();
          ctx.restore();
        }

        if (sys.kind && sys.kind !== "normal") {
          ctx.save();
          ctx.beginPath();
          ctx.arc(p.x, p.y, r + 3, 0, Math.PI * 2);
          let kindColor = "#ffb86c";
          if (sys.kind === "forge") kindColor = "#bd93f9";
          else if (sys.kind === "hive") kindColor = "#50fa7b";
          ctx.strokeStyle = kindColor;
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
        }

        ctx.save();
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.restore();

        // Fleets at system
        const fleetsHere = fleetsBySystem[sys.id] || [];
        if (fleetsHere.length) {
          const orbit = r + 6;
          const n = fleetsHere.length;
          fleetsHere.forEach((fl, i) => {
            const angle = 2 * Math.PI * (i / n);
            const fx = p.x + orbit * Math.cos(angle);
            const fy = p.y + orbit * Math.sin(angle);
            const strength = typeof fl.strength === "number" ? fl.strength : 0;
            let fr = 1.5 + Math.log10(strength + 1);
            fr = Math.max(1.5, Math.min(fr, 4.0));
            const fcol = factionColors[fl.owner] || "#ffffff";
            ctx.save();
            ctx.beginPath();
            ctx.arc(fx, fy, fr, 0, Math.PI * 2);
            ctx.fillStyle = fcol;
            ctx.fill();
            ctx.restore();
          });
        }

        ctx.save();
        ctx.fillStyle = "rgba(220, 230, 255, 0.85)";
        ctx.font = "10px monospace";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.fillText(sys.id, p.x, p.y + r + 2);
        ctx.restore();
      });

      // Enroute fleets (draw lines)
      ctx.save();
      ctx.strokeStyle = "rgba(200,200,255,0.4)";
      ctx.lineWidth = 1.5;
      enrouteFleets.forEach(fl => {
        const from = lastProj[fl.enroute_from];
        const to = lastProj[fl.enroute_to];
        if (!from || !to) return;
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      });
      ctx.restore();
    }

    function connect() {
      const wsUrl = "ws://backend.seketa.it:8000/ws";
      const ws = new WebSocket(wsUrl);
      ws.onmessage = (ev) => {
        const data = JSON.parse(ev.data);
        if (typeof data.tick_delay_ms === "number") {
          tickDelayMs = data.tick_delay_ms;
        } else if (typeof data.tick_delay === "number") {
          tickDelayMs = data.tick_delay * 1000;
        }
        scheduleRender(data);
      };
      ws.onclose = () => setTimeout(connect, 2000);
      ws.onerror = () => ws.close();
    }
    connect();

    function scheduleRender(data) {
      lastFrame = data;
      const now = performance.now();
      const minInterval = tickDelayMs || 0;
      if (renderScheduled || (minInterval > 0 && now - lastRenderTs < minInterval)) {
        return;
      }
      renderScheduled = true;
      requestAnimationFrame(() => {
        render(lastFrame);
        lastRenderTs = performance.now();
        renderScheduled = false;
      });
    }
  </script>
</body>
</html>
